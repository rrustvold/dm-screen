<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Iframe Window</title>
<!--  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">-->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />

  <style>
    @font-face {
  font-family: 'myFont';
      src: url('/itc-benguiat-std/ITCBenguiatStdBoldCn.OTF') format('opentype');
    }

    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      pointer-events: none;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    iframe {
      width: 1080px;
      height: 1920px;
      border: none;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: auto;
      /* Rotate the iframe by 180 degrees */
      transform: rotate(180deg);
      /* Optional: maintain the iframe's appearance even after rotation */
      transform-origin: center;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 1080;
      height: 1920;
      background: rgba(0, 0, 0, 0.1);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2;
      display: flex; /* Initially hidden */
      pointer-events: none;
    }

    .hide {
      position: absolute;
      top: 0;
      left: 0;
      width: 1080;
      height: 1920;
      /* background: rgba(0, 0, 0, 0.1); */
      color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      display: flex; /* Initially hidden */
      pointer-events: none;
    }


    .hidden {
      display: none;
    }

    canvas {
      width: 1080px;
      height: 1920px;
      z-index: 3;
      pointer-events: auto;
      /* Rotate the iframe by 180 degrees */
      /*transform: rotate(180deg);*/
      /*!* Optional: maintain the iframe's appearance even after rotation *!*/
      /*transform-origin: center;*/
    }


  </style>
</head>
<body>

  <iframe src="https://hextml.playest.net/#&togetherjs=52ErIPj2jj" id="iframe"></iframe>
  <div class="overlay" id="overlay">
    <canvas id="canvas" class="canvas" width="1080" height="1920"></canvas>
  </div>


  <script>
    document.getElementById("iframe").src = opener.document.getElementById("hex-address").value;
    // Function to toggle the overlay visibility

    
    
    

    // step 1: clear everything
    // step 2: draw initiative track
    // step 3: draw grid lines
    // step 4: style zones
    // step 5: draw circles
    // step 6: listen for clicks
    function HexTile(i, j, x , y) {
      this.i = i;
      this.j = j;
      this.x = x;
      this.y = y;
      this.state = "hidden";
      this.terrain = "grass";
      this.elevation = 0;
      this.elevationDirection = "up";
      this.assets = [];
      this.effects = [];

      this.drawGround = () => {
        if (this.state === "hidden"){
          return;
        }
        ctx.save();
        ctx.shadowColor = "#152213";
        ctx.shadowBlur = 50;
        ctx.strokeStyle = "#152213";
        drawHex(this.x, this.y);
        ctx.fillStyle = get_fill_style(this.terrain);
        ctx.fill();
        ctx.restore();
      }

      this.drawElevation = (elevationOffset=0) => {
        if (this.state === "hidden" || this.elevation < 1){
          return;
        }

          ctx.save();
          ctx.shadowColor = "#152213";
          ctx.shadowBlur = 50;
          ctx.strokeStyle = "#152213";
          ctx.lineCap = "round";
          

          let h = r_hex * Math.sin(Math.PI / 3);
          let w = r_hex * Math.cos(Math.PI / 3);

          let pt0;
          let pt1;
          let pt2;
          let pt3;
          let pt4;
          let pt5;
          let pt6;
          let pt7;

          if (this.elevationDirection === "up"){
            pt0 = [this.x - r_hex, this.y];
            pt1 = [this.x - r_hex, this.y - (this.elevation - elevationOffset)*h];
            pt2 = [this.x - w, this.y -  (this.elevation - elevationOffset)*h - h];
            pt3 = [this.x + w, this.y -  (this.elevation - elevationOffset)*h - h];
            pt4 = [this.x + r_hex, this.y -  (this.elevation - elevationOffset)*h];
            pt5 = [this.x + r_hex, this.y];
            pt6 = [this.x + w, this.y - h];
            pt7 = [this.x - w, this.y - h];
          } else if (this.elevationDirection === "down"){
            pt0 = [this.x - r_hex, this.y];
            pt1 = [this.x - r_hex, this.y + (this.elevation - elevationOffset)*h];
            pt2 = [this.x - w, this.y +  (this.elevation - elevationOffset)*h + h];
            pt3 = [this.x + w, this.y +  (this.elevation - elevationOffset)*h + h];
            pt4 = [this.x + r_hex, this.y +  (this.elevation - elevationOffset)*h];
            pt5 = [this.x + r_hex, this.y];
            pt6 = [this.x + w, this.y + h];
            pt7 = [this.x - w, this.y + h];
          }
          

          ctx.fillStyle = cliffPattern;  
          ctx.beginPath();
          
          // hilight
          ctx.fillStyle = cliffHilightPattern;
          ctx.moveTo(pt0[0], pt0[1]);
          ctx.lineTo(pt1[0], pt1[1]);  
          ctx.lineTo(pt2[0], pt2[1]);
          ctx.lineTo(pt7[0], pt7[1]);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // middle
          ctx.fillStyle = cliffPattern;  
          ctx.beginPath();
          ctx.moveTo(pt7[0], pt7[1]);
          ctx.lineTo(pt2[0], pt2[1]);
          ctx.lineTo(pt3[0], pt3[1]);
          ctx.lineTo(pt6[0], pt6[1]);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          //shadow
          ctx.fillStyle = cliffShadowPattern;  
          ctx.beginPath();
          ctx.moveTo(pt6[0], pt6[1]);
          ctx.lineTo(pt3[0], pt3[1]);
          ctx.lineTo(pt4[0], pt4[1]);
          ctx.lineTo(pt5[0], pt5[1]);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          ctx.restore();
        
      }

      this.drawAssets = () => {
        if (this.state === "hidden"){
          return;
        }
        ctx.save();
        ctx.shadowBlur = 0;
        this.assets.forEach(asset => {
          ctx.save();
          let width = asset.img.width;
          let height = asset.img.height;
          ctx.translate(asset.x + width/2, asset.y + height/2);
          ctx.scale(1, -1);
          ctx.drawImage(asset.img, -width/2, -height/2);
          ctx.restore();
        })
        ctx.restore();
      }
    }

    let zoneContents = [];
    zoneContents = [];
      for (let i=0; i < 6; i++){
        let row = []
        for (let j=0; j<3; j++){
          row.push([]);
        }
        zoneContents.push(row);
      }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let tree_img = new Image();
    tree_img.src = "/pixel-art/PNG/assets/Trees_shadow/Autumn_tree1.png";
   
    let treeStump = new Image();
    treeStump.src = "/pixel-art/PNG/assets/Trees_texture_shadow/Broken_tree3.png"
   
    let myGrass = new Image();
    myGrass.src = "/mygrass2.png";
    let grassPattern;
    myGrass.onload = () => {grassPattern = ctx.createPattern(myGrass, "no-repeat")};
    

    let cliff = new Image();
    cliff.src = "/cliff.png";
    let cliffPattern;
    cliff.onload = () => {cliffPattern = ctx.createPattern(cliff, "repeat")};

    let cliffHilight = new Image();
    cliffHilight.src = "/cliff-hilight.png";
    let cliffHilightPattern;
    cliffHilight.onload = () => {cliffHilightPattern = ctx.createPattern(cliffHilight, "repeat")};

    let cliffShadow = new Image();
    cliffShadow.src = "/cliff-shadow.png";
    let cliffShadowPattern;
    cliffShadow.onload = () => {cliffShadowPattern = ctx.createPattern(cliffShadow, "repeat")};
    


    ctx.font = "40px myFont";
    ctx.shadowBlur = 50;
    ctx.shadowColor = "#d08069";
    
    let keyPressed = {};
    window.addEventListener('keydown', (event) => {keyPressed[event.key] = true});
    window.addEventListener('keyup', (event) => {delete keyPressed[event.key]});

    canvas.addEventListener('mousedown', handleClick);
    canvas.addEventListener('contextmenu', function(event) {
      event.preventDefault();
    });
    const squareSize = 108;
    // multiply by 1.78 to get r=6in
    const r_hex = 1080 / 7;
    const hex_row_size = 5;
    const hex_col_size = 8;
    const deg_60 = 2 * Math.PI / 6;
    let hex_tiles = [];
    // initialize all the hex tiles
    for (let j=0; j < hex_col_size; j++){
        let row = [];
        let x = .5 * r_hex;
        let y = r_hex * Math.sin(deg_60) + j * 2*r_hex*Math.sin(deg_60) + squareSize;
        row.push(new HexTile(j + 1, 1, x, y));
        for (let i=1; i < hex_row_size; i++) {
          x += r_hex * (1 + Math.cos(deg_60));
          y += (-1) ** i * r_hex * Math.sin(deg_60);
          row.push(new HexTile(j+ 1, i + 1, x, y));
        }
        hex_tiles.push(row);
      }

    // A global time tracker for animations
    let lastTime = Date.now();
    let now = Date.now();
    let dt = now - lastTime;
    function loop() {
      now = Date.now();
      dt = now - lastTime;
      lastTime = now;
      let table_type = opener.document.getElementById('table-type').value;

      if (table_type === "battle"){
        canvas.style.pointerEvents = "auto";
        lastType = table_type;
        let overlay = document.getElementById('overlay');
        overlay.style.visibility = 'visible';
        let style = opener.document.getElementById('battle-style').value;
        overlay.style.backgroundColor = "rgb(24,29,51)"
        // overlay.style.backgroundImage = `url("/${style}.jpg")`;
        // summer grass
        // overlay.style.backgroundColor = "#6ae457";

        // fall grass
        // overlay.style.backgroundColor = "#f9d401";

        document.getElementById("iframe").classList.add('hidden');

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // drawZones();

        drawHexTiles();

        hex_tiles.forEach(row => {
          row.forEach(tile => tile.drawAssets())
        })

        // weather and clouds
        // clouds.forEach(cloud => cloud.draw());
        // ctx.save();
        // ctx.fillStyle = "rgba(30,28,189,0.19)";
        // ctx.fillRect(0, 0, 1080, 1920);
        // ctx.restore();

        // fillZones();
        drawInitiativeTrack();
        drawInitiativeTokens();
        drawChyron();
        

        window.requestAnimationFrame(loop);
      } else {
        canvas.style.pointerEvents = "none";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        wilderness();
        drawChyron();
        window.requestAnimationFrame(loop);
      }
    }

    function toggleOverlay() {
      const overlay = document.getElementById('overlay');
      overlay.style.display = overlay.style.display === 'none' ? 'flex' : 'none';

    }
    window.toggleOverlay = toggleOverlay;

    function hide() {
      let overlay = document.getElementById('overlay');
      overlay.style.visibility = 'hidden';
      document.getElementById("iframe").classList.add('hidden');
    }
    // window.hide = hide;

    function clear() {
      hex_tiles.forEach(row => {
        row.forEach(tile => {
          tile.elevation = 0;
          tile.state = "hidden";
          tile.assets = [];
          tile.elevationDirection = "up";
        })
      })
    }

    function wilderness() {
      let overlay = document.getElementById('overlay');
      overlay.style.visibility = 'visible';
      overlay.style.backgroundImage = null;
      overlay.style.backgroundColor = null;
      document.getElementById("iframe").classList.remove('hidden');

      wildernessOverlay();
    }

    function get_fill_style(terrain){
      return grassPattern;
      switch (terrain) {
        case "grass":
          let color = opener.document.getElementById("color").value;
          return color;
          // return "#37592b";
          return "#f9d401";
      }
    }
    function battle() {

      let overlay = document.getElementById('overlay');
      overlay.style.visibility = 'visible';
      let style = opener.document.getElementById('battle-style').value;
      // overlay.style.backgroundImage = `url("/${style}.jpg")`;

      document.getElementById("iframe").classList.add('hidden');

      loop();
    }
    window.battle = battle;

    let clouds = [];
    for (let i=0; i<5; i++){
      clouds.push(new Cloud());
    }


    function circle(num, currentHp, maxHp, name){
      let x = squareSize / 2;
      let y = squareSize / 2;

      if (num <= 11){
        x = 1080 - squareSize/2;
        y = (11 - num) * squareSize + squareSize/2;
      } else if (num < 20) {
        y = squareSize / 2;
        x = (20 - num) * squareSize + squareSize/2;
      } else {
        x = squareSize / 2;
        y = (num - 20) * squareSize + squareSize/2;
      }
      ctx.save();
      const grad=ctx.createRadialGradient(x,y,40,x,y,80);
      grad.addColorStop(0,"rgba(255,219,219,0.25)");
      grad.addColorStop(0.3,"pink");
      grad.addColorStop(1,"#7e0000");
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 75, y);
      ctx.arc(x, y, 75, 0, Math.PI * 2 * currentHp / maxHp);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = "middle";
      ctx.fillStyle = "red";
      if (name === null){
        ctx.font = '48px "Material Symbols Outlined"';
        ctx.fillText("skull", x, y);
      } else {
        ctx.fillText(name, x, y);
      }



      ctx.restore();
    }

    let fancyHue = 0;
    
    function wildernessOverlay() {
      fancyHue += 10*dt/1000;
      // fancyHue = 180;

      if (fancyHue >= 360) fancyHue = 0;
      const gradient = ctx.createLinearGradient(0, canvas.height / 2, canvas.width, canvas.height / 2);
      gradient.addColorStop(0, `hsl(${fancyHue}, 100%, 50%)`);
      gradient.addColorStop(1, `hsl(${(fancyHue + 120) % 360}, 100%, 50%)`);



      // ctx.globalCompositeOperation = "overlay";
      // let textFillStyle = "rgb(237,237,255)";
      // Apply glow effect with shadow
      // ctx.shadowColor = `hsl(${fancyHue}, 100%, 60%)`;
      // ctx.shadowBlur = 20;
      // ctx.shadowOffsetY = 20;
      // ctx.shadowOffsetX = 10;

      let lineStrokeStyle = gradient;
      let fillStyle = "rgb(70,3,3)";
      let textFillStyle = "white";
      let strokeWidth = 5;
      // Draw Sentry / Nav Tile
      ctx.save();
      ctx.fillStyle = fillStyle;
      ctx.strokeStyle = lineStrokeStyle;
      ctx.lineWidth = 10;
      ctx.textAlign = 'center';


      ctx.save();
      let sentry_tile = hex_tiles[1][2];
      drawHex(sentry_tile.x, sentry_tile.y);
      ctx.fill();
      ctx.save();
      ctx.fillStyle = textFillStyle;
      ctx.lineWidth = strokeWidth;
      ctx.beginPath();
      ctx.moveTo(sentry_tile.x - r_hex, sentry_tile.y);
      ctx.lineTo(sentry_tile.x + r_hex, sentry_tile.y);
      ctx.stroke();
      ctx.translate(sentry_tile.x, sentry_tile.y + r_hex/2);
      ctx.rotate(Math.PI);
      ctx.fillText("Sentry", 0, 0);
      ctx.translate(0, r_hex);
      ctx.fillText("Navigator", 0, 0);
      ctx.restore();

      // Draw mapper
      ctx.save();
      let mapper_tile = hex_tiles[0][2];
      drawHex(mapper_tile.x, mapper_tile.y);
      ctx.fill();
      ctx.fillStyle = textFillStyle;
      ctx.lineWidth = strokeWidth;
      ctx.beginPath();
      ctx.moveTo(mapper_tile.x - r_hex, mapper_tile.y);
      ctx.lineTo(mapper_tile.x + r_hex, mapper_tile.y);
      ctx.stroke();
      ctx.translate(mapper_tile.x, mapper_tile.y - r_hex/2);
      ctx.rotate(Math.PI);
      ctx.fillText("Sentry", 0, 0);
      ctx.translate(0, -r_hex);
      ctx.fillText("Mapper", 0, 0);
      ctx.restore();

      // Draw Forager
      ctx.save();
      let forager_tile = hex_tiles[1][1];
      drawHex(forager_tile.x, forager_tile.y);
      ctx.fill();
      ctx.fillStyle = textFillStyle;
      ctx.lineWidth = strokeWidth;
      ctx.beginPath();
      ctx.moveTo(forager_tile.x + r_hex * Math.cos(deg_60), forager_tile.y - r_hex*Math.sin(deg_60));
      ctx.lineTo(forager_tile.x, forager_tile.y);
      ctx.lineTo(forager_tile.x + r_hex * Math.cos(deg_60), forager_tile.y + r_hex*Math.sin(deg_60));
      ctx.stroke();
      ctx.translate(forager_tile.x + r_hex/2, forager_tile.y);
      ctx.rotate(Math.PI/2);
      ctx.fillText("Forage", 0, 0);
      ctx.translate(0, r_hex);
      ctx.fillText("Sentry", 0, 0);
      ctx.restore();

      // Draw 2ndForager
      ctx.save();
      forager_tile = hex_tiles[1][3];
      drawHex(forager_tile.x, forager_tile.y);
      ctx.fill();
      ctx.fillStyle = textFillStyle;
      ctx.lineWidth = strokeWidth;
      ctx.beginPath();
      ctx.moveTo(forager_tile.x - r_hex * Math.cos(deg_60), forager_tile.y - r_hex*Math.sin(deg_60));
      ctx.lineTo(forager_tile.x, forager_tile.y);
      ctx.lineTo(forager_tile.x - r_hex * Math.cos(deg_60), forager_tile.y + r_hex*Math.sin(deg_60));
      ctx.stroke();
      ctx.translate(forager_tile.x - r_hex/2, forager_tile.y);
      ctx.rotate(-1 * Math.PI/2);
      ctx.fillText("Forage", 0, 0);
      ctx.translate(0, r_hex);
      ctx.fillText("Sentry", 0, 0);
      ctx.restore();

      ctx.beginPath();
      ctx.arc(sentry_tile.x, sentry_tile.y - r_hex, 3*r_hex, 0, 2*Math.PI);
      ctx.stroke();

      ctx.restore();
    }
    
    function drawZones() {
      const numZones = window.opener.document.getElementById("zoneRows").value;
      const zoneWidth = window.opener.document.getElementById("zoneCols").value;
      const initiativeDepth = squareSize * 11;
      const width = 1080 - 2 * squareSize;
      const height = 1920 - squareSize;
      const left = squareSize;
      const right = 1080 - squareSize;

      const tileWidth = width / 12;
      const tileHeight = height / 12;

      const zoneHeight = (1920 - squareSize) / numZones;
      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(255, 255, 255, .5)";


      for (let i=0; i < numZones; i++) {
        ctx.beginPath();
        let elevation = zoneHeight * (i + 1) + squareSize;
        let leftEnd = left;
        let rightEnd = right;
        if (elevation >= initiativeDepth) {
          leftEnd = 0;
          rightEnd = 1080;
        }
        if (i < numZones - 1) {
          ctx.moveTo(leftEnd, elevation);
          ctx.lineTo(rightEnd, elevation);
          ctx.stroke();
        }
      }

      for (let j=0; j < zoneWidth - 1; j++){
        let x = (j + 1) * 1080 / zoneWidth;
        ctx.beginPath()
        ctx.moveTo(x, squareSize);
        ctx.lineTo(x, 1920);
        ctx.stroke();
      }
      
    }

    function handleClick(event) {
      if (opener.document.getElementById('table-type').value === "wilderness") {
        return
      }
      // Get the click coordinates relative to the canvas
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // figure out which tile the click is closest to
      let closest_tile = null;
      let distance = 10000;
      hex_tiles.forEach(row => row.forEach(
              tile => {
                let manhattan = Math.abs(tile.x - x) + Math.abs(tile.y - y);
                if (manhattan < distance){
                  distance = manhattan;
                  closest_tile = tile;
                }
              }
      ));

      const radios = opener.document.querySelectorAll('input[name="func"]');
      
      // Find the selected radio button
      let selectedValue;
      radios.forEach((radio) => {
        if (radio.checked) {
          selectedValue = radio.id;
        }
      });
      console.log(selectedValue);
      switch (selectedValue) {
        case "hide":
          closest_tile.state = closest_tile.state === "hidden" ? "visible" : "hidden";
          break;

        case "tree":
          closest_tile.assets.push(
            {
              img: tree_img,
              x: x,
              y: y,
            }
          );
          break;
        case "tree-stump":
          closest_tile.assets.push(
            {
              img: treeStump,
              x: x,
              y: y,
            }
          );
          break;
        case "elevate":
          if (event.button === 2){
            closest_tile.elevation -= 1;
          } else {
            closest_tile.elevation += 1;
          }

          if (keyPressed["ArrowUp"]) {
            closest_tile.elevationDirection = "up";
          } else if (keyPressed["ArrowLeft"]) {
            closest_tile.elevationDirection = "left";
          } else if (keyPressed["ArrowRight"]) {
            closest_tile.elevationDirection = "right";
          } else if (keyPressed["ArrowDown"]) {
            closest_tile.elevationDirection = "down";
          }
          
          break;

      }

    }

    function fillZones(){  
      const numRows = window.opener.document.getElementById("zoneRows").value;
      const numCols = window.opener.document.getElementById("zoneCols").value;
      const colWidth = 1080 / numCols;
      const rowHeight = (1920 - squareSize) / numRows;
      for (let i=0; i < zoneContents.length; i++) {
        let row = zoneContents[i];
        for (let j=0; j < row.length; j++){
          let fillTools = row[j];
          for (let k=0; k < fillTools.length; k++) {
            let fillTool = fillTools[k];
            if (fillTool === "difficult-terrain"){
              ctx.fillStyle = "rgba(100, 100, 0, .75)";
            } else if (fillTool === "dark") {
              ctx.fillStyle = "rgba(0, 0, 0, .75)";
            } else if (fillTool === "light") {
              ctx.fillStyle = "rgba(255, 255, 255, .25)";
            } else if (fillTool === "water") {
              ctx.fillStyle = "rgba(20, 20, 240, .75)";
            }
            if (fillTool === "add-cover"){
              // const grad=ctx.createRadialGradient(x,y,40,x,y,80);
              // grad.addColorStop(0,"lightblue");
              // grad.addColorStop(0.3,"pink");
              // grad.addColorStop(1,"darkblue"); 
              // ctx.beginPath();
              // ctx.arc(x, y, 75, 0, Math.PI * 2);
              // ctx.fillStyle = grad;
              // ctx.fill();
            } else if (fillTool === "remove") {
              ctx.clearRect(colClicked * colWidth + 5, rowClicked * rowHeight + squareSize + 5, colWidth - 10, rowHeight - 10);
            } else{
              ctx.fillRect(j * colWidth + 5, i * rowHeight + squareSize + 5, colWidth - 10, rowHeight - 10);
            }
          }
        }
      }
    }


    
    function drawInitiativeTrack(){ 
      let color = "black";
      let style = opener.document.getElementById('battle-style').value;
      // ctx.save();
      // ctx.shadowBlur = 0;
      //   ctx.shadowColor = null;
      if (style === "forest") {
        // gold
        // color = '#f9c366';
        // sky
        color = 'rgba(164,240,255,0.75)';

        // ctx.shadowOffsetX = 10;
        // ctx.shadowOffsetY = 15;

      } else if (style === "dungeon"){
        color = 'rgba(240, 50, 50, .45)';
      }
      ctx.save();

      ctx.fillStyle = color;
      let radius = 50;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(1080, 0);
      ctx.lineTo(1080, squareSize*11);
      ctx.lineTo(1080 - squareSize + radius, squareSize*11);
      ctx.arc(1080 - squareSize + radius, squareSize*11 - radius, radius,-1*Math.PI/2, -1*Math.PI);
      ctx.lineTo(1080 - squareSize, squareSize + radius);
      // ctx.arcTo(1080 - squareSize, squareSize + radius, 1080 - squareSize - radius, squareSize, radius);
      ctx.arc(1080 - squareSize - radius, squareSize + radius, radius, 0, -1*Math.PI/2, true);
      ctx.lineTo(squareSize, squareSize);
      ctx.lineTo(squareSize, squareSize*11);
      ctx.lineTo(0, squareSize*11);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'white'; // Text color
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Draw the left
      for (let i=0; i<11; i++){
        // Save the current state before rotation
        ctx.save();
        // Move the origin to the center (to rotate around the center)
        let x = squareSize/2
        let y = i*squareSize + squareSize/2;
        ctx.translate(x, y);

        // Rotate 45 degrees (in radians)
        const angle = 90 * (Math.PI / 180); // Convert degrees to radians
        ctx.rotate(angle);
        ctx.fillText(`${20 + i}`, 0, 0);
        ctx.restore();
      }

      for (let i=0; i<8; i++) {
        ctx.save();
        let x = (i+1)*squareSize + squareSize/2;
        let y = squareSize/2;
        ctx.translate(x, y);
        const angle = 180 * (Math.PI / 180);
        ctx.rotate(angle);
        ctx.fillText(`${19 - i}`, 0, 0);
        ctx.restore();
      }
      
      for (let i=0; i<11; i++){
        ctx.save();
        let x = squareSize*10 - squareSize/2;
        let y = i*squareSize + squareSize/2
        ctx.translate(x, y);
        const angle = 270 * (Math.PI / 180);
        ctx.rotate(angle);
        ctx.fillText(`${11 - i}`, 0, 0);
        ctx.restore();
      }
      ctx.restore();
    }

    function drawInitiativeTokens(){
      for (let i=0; i < 10; i++){
        let initiative = opener.document.getElementById(`initiative-${i}`);
        let name = opener.document.getElementById(`monster-name-${i}`);
        name = name ? name.value : null;

        let maxHp = opener.document.getElementById(`hit-point-maximum-${i}`);
        if (maxHp !== null){
          maxHp = maxHp.value;
        } else {
          maxHp = 1;
        }

        let currentHp = opener.document.getElementById(`hit-points-${i}`);
        if (currentHp !== null) {
          currentHp = currentHp.value;
        } else {
          currentHp = 1;
        }
        
        if (initiative !== null){
          if (initiative.value !== null && initiative.value > 0 && initiative.value < 31){
            circle(initiative.value, currentHp, maxHp, name);
          }
        } else {
          break;
        }
      }
    }

    function drawHex(x, y){
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          ctx.lineTo(x + r_hex * Math.cos(deg_60 * i), y + r_hex * Math.sin(deg_60 * i));
        }
        ctx.closePath();
        ctx.stroke();


    }

    function drawHexTiles() {
      ctx.save()
      ctx.strokeStyle = "#f9c366";
      ctx.lineWidth = 6;
      let maxElevation = 0;
      hex_tiles.forEach(row => {
        row.forEach(tile => {
          if (tile.elevation > maxElevation){
            maxElevation = tile.elevation;
          }
        })
      })

      for (let i=0; i <= maxElevation; i++){
        if (i > 0){
          
        }
        hex_tiles.forEach(row => {
          row.forEach(tile => {
            if (tile.elevation >= i){
              tile.drawElevation(elevationOffset=i > 1 ? i-1: 0);
            }
          })
          row.forEach(tile => {
            if (tile.elevation === i){
              tile.drawGround();
            }
          })
        })
      }

      
      ctx.restore();
    }

    function hideAll(){
      hex_tiles.forEach(row => row.forEach(tile => tile.state = "hidden"));
    }
    window.hideAll = hideAll;

    function showAll() {
      hex_tiles.forEach(row => row.forEach(tile => tile.state = "visible"));
    }
    window.showAll = showAll;


    function Cloud() {
      this.x = Math.random() * 1080;
      this.y = Math.random() * 1920;
      this.v_x = .005;
      this.v_y = 0;
      this.last_time = Date.now();


      this.circles = [];
      for (let i =0; i < 5; i++){
        this.circles.push(
          {
            x: Math.random()*50,
            y: Math.random()*50,
            r: Math.random()*200 + 100,
            color: "rgba(200,200,200,.1)",
          }
        )
      }

      this.draw = () => {
        ctx.save();
        this.circles.forEach(circle => {
          ctx.fillStyle = circle.color;
          ctx.beginPath();
          ctx.arc(circle.x + this.x, circle.y + this.y, circle.r, 0, 2*Math.PI);
          ctx.fill();
        });
        let now = Date.now();
        let dt = now - this.last_time;
        this.x += this.v_x * dt;
        if (this.x > 1080 + 500) this.x = -500;
        this.y += this.v_y * dt;
        if (this.y > 1920 + 500) this.y = -500;
        this.last_time = now;
        ctx.restore();
      }

    }

    function createFrostedGlassEffect(x, y, width, height, radii) {
      // Step 1: Extract the background image portion that will be "behind the glass"
      ctx.save();
      const backgroundPortion = ctx.getImageData(x, y, width, height);

      // Step 2: Create a new offscreen canvas to blur the portion of the background
      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');
      offscreenCanvas.width = width;
      offscreenCanvas.height = height;

      // Step 3: Draw the background portion to the offscreen canvas
      offscreenCtx.putImageData(backgroundPortion, 0, 0);

      // Step 4: Apply blur filter to the offscreen canvas
      offscreenCtx.filter = 'blur(5px)';
      offscreenCtx.drawImage(offscreenCanvas, 0, 0);  // Redraw the blurred image

      // Step 5: Draw the blurred portion back to the main canvas
      ctx.drawImage(offscreenCanvas, x, y);

      // Step 6: Overlay a semi-transparent white rectangle (for the frosted glass effect)
      ctx.globalAlpha = 0.5;  // Set transparency (adjust as needed)
      ctx.fillStyle = 'white';
      ctx.fillRect(x, y, width, height);

      // Reset alpha
      ctx.globalAlpha = 1.0;

      // Step 7: Optionally, add a border or highlight to the frosted glass effect
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';  // Light border
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);
      ctx.restore();
    }

    function drawChyron(){
      // createFrostedGlassEffect(
      //   .5 * squareSize,
      //   1920 - 4.5*squareSize,
      //   1080 - squareSize,
      //   4 * squareSize,
      // );
      ctx.save();
      ctx.fillStyle = 'rgba(164,240,255,0.75)';
      ctx.beginPath();
      ctx.roundRect(1080, 1920, -2.5*squareSize, -squareSize, [0, 0, 50, 0]);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(1080 / 2, 1920/2);
      ctx.rotate(Math.PI);
      ctx.translate(-1080/2, -1920/2);


      ctx.fillStyle = 'white';
      ctx.textAlign = "left";
      let text_x = squareSize / 3;
      let text_y = squareSize / 2;
      let temperature = opener.document.getElementById("tempPanel").innerText;
      ctx.fillText(`${temperature} °F`, text_x, text_y);
      temperature = Number(temperature);
      text_x += 90;
      ctx.font = '48px "Material Symbols Outlined"';
      let tempIcon;
      if (temperature >= 100) {
        tempIcon = 'sunny';
      } else if (temperature <= 0) {
        tempIcon = 'ac_unit'
      }
      if (tempIcon) {
        ctx.fillText(tempIcon, text_x, text_y);
        text_x += 50;
      }

      let wind = opener.document.getElementById("windPanel").innerText;
      let windIcon;
      if (wind === 'Light'){

      } else if (wind.startsWith('Strong')){
        windIcon = 'air';
      }
      if (windIcon) {
        ctx.fillText(windIcon, text_x, text_y);
        text_x += 50;
      }

      let precip = opener.document.getElementById("precipPanel").innerText;
      let precipIcon;
      if (precip.startsWith("Light")){
        if (temperature <= 35) {
          precipIcon = "cloudy_snowing";
        } else {
          precipIcon = "rainy_light";
        }
      } else if (precip.startsWith("Heavy")){
        if (temperature <= 35){
          precipIcon = "weather_snowy";
        } else {
          precipIcon = "rainy_light";
        }
      }
      if (precipIcon) {ctx.fillText(precipIcon, text_x, text_y)}


      // ctx.textAlign = "left";
      // ctx.font = "30px myFont";
      // ctx.fillText(`${temperature}, ${wind} wind, ${precip}`, squareSize, squareSize);
      // for (let i=0; i < 3; i++){
      //
      // }
      ctx.restore();
    }



  </script>
</body>
</html>
